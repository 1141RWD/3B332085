<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ğŸ§± æ‰“ç£šå¡Šï¼šé—œå¡é€²åŒ–ç‰ˆ</title>
    <style>
        :root {
            --neon-blue: #00ffff;
            --neon-pink: #ff00ff;
        }
        * { box-sizing: border-box; }
        body {
            margin: 0; background: #0a0a12; color: white;
            text-align: center; font-family: 'Segoe UI', sans-serif;
            overflow: hidden; touch-action: none;
            display: flex; flex-direction: column; height: 100vh;
        }

        /* é ‚éƒ¨æ•´åˆæ¬„ */
        #header {
            display: flex; justify-content: flex-end; align-items: center;
            padding: 10px 15px; background: rgba(255,255,255,0.05);
            gap: 15px; height: 50px;
        }
        .stat { font-weight: bold; font-size: 0.9rem; }
        .stat span { color: var(--neon-blue); }

        #home-btn-container {
            position: fixed; top: 10px; left: 10px; z-index: 9999;
            display: flex; align-items: center; gap: 5px;
            padding: 6px 12px; background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(8px); border: 1px solid rgba(0, 242, 254, 0.5);
            border-radius: 50px; color: #00f2fe; cursor: pointer;
            font-size: 12px; text-decoration: none;
        }

        /* éŠæˆ²å€åŸŸ */
        #canvas-container {
            flex: 1; /* è‡ªå‹•åˆ†é…å‰©é¤˜ç©ºé–“ */
            display: flex; align-items: center; justify-content: center;
            padding: 10px;
        }
        canvas { 
            max-width: 100%; max-height: 100%; 
            background: #000; border: 2px solid var(--neon-blue);
            border-radius: 8px; box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
        }

        /* åº•éƒ¨æ§åˆ¶å€ */
        .controls { padding: 10px; }
        .hint { color: #666; font-size: 0.75rem; margin-bottom: 8px; }
        button {
            padding: 10px 20px; font-size: 0.9rem; border-radius: 30px;
            border: 1px solid var(--neon-blue); background: transparent;
            color: var(--neon-blue); cursor: pointer;
        }
    </style>
</head>
<body>

<a id="home-btn-container" href="index.html">
    <svg viewBox="0 0 24 24" width="18" height="18"><path fill="currentColor" d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg>
    <span>å¤§å»³</span>
</a>

<div id="header">
    <div class="stat">LV: <span id="lv-txt">1</span></div>
    <div class="stat">SCORE: <span id="score-txt">0</span></div>
</div>

<div id="canvas-container">
    <canvas id="game" width="480" height="320"></canvas>
</div>

<div class="controls">
    <p class="hint">æ‹–æ›³ç•«é¢ä¸‹æ–¹æˆ–æ»‘å‹•ä¾†ç§»å‹•æ“‹æ¿</p>
    <button onclick="resetGame(true)">é‡ç½®éŠæˆ²</button>
</div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

let level = 1;
let score = 0;
let x, y, dx, dy, ballRadius = 8;
let paddleHeight = 12, paddleWidth = 90, paddleX;
let bricks = [], rowCount, colCount;
const brickPadding = 8, brickOffsetTop = 30, brickOffsetLeft = 15;

function initLevel() {
    rowCount = Math.min(2 + level, 6);
    colCount = 6;
    x = canvas.width / 2;
    y = canvas.height - 40;
    let speed = 2 + (level * 0.4);
    dx = speed; dy = -speed;
    paddleX = (canvas.width - paddleWidth) / 2;

    bricks = [];
    for (let c = 0; c < colCount; c++) {
        bricks[c] = [];
        for (let r = 0; r < rowCount; r++) {
            bricks[c][r] = { x: 0, y: 0, status: 1, color: `hsl(${(r * 40) + (level * 20)}, 70%, 60%)` };
        }
    }
    updateUI();
}

function handleMove(e) {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    // é‡è¦ï¼šè¨ˆç®—ç¸®æ”¾å¾Œçš„ç²¾ç¢ºæ¯”ä¾‹
    const scaleX = canvas.width / rect.width;
    const relativeX = (clientX - rect.left) * scaleX;
    
    if (relativeX >= 0 && relativeX <= canvas.width) {
        paddleX = relativeX - paddleWidth / 2;
    }
}

document.addEventListener("mousemove", handleMove);
document.addEventListener("touchmove", handleMove, { passive: false });

function collisionDetection() {
    const bw = (canvas.width - (brickOffsetLeft * 2) - (colCount - 1) * brickPadding) / colCount;
    const bh = 18;
    for (let c = 0; c < colCount; c++) {
        for (let r = 0; r < rowCount; r++) {
            const b = bricks[c][r];
            if (b.status === 1) {
                const bx = c * (bw + brickPadding) + brickOffsetLeft;
                const by = r * (bh + brickPadding) + brickOffsetTop;
                b.x = bx; b.y = by;

                if (x > bx && x < bx + bw && y > by && y < by + bh) {
                    dy = -dy;
                    b.status = 0;
                    score += 10;
                    updateUI();
                    if (checkWin()) {
                        level++;
                        alert(`ğŸŒŸ é—œå¡å®Œæˆï¼æº–å‚™é€²å…¥ LV ${level}`);
                        initLevel();
                    }
                }
            }
        }
    }
}

function checkWin() {
    return bricks.every(col => col.every(b => b.status === 0));
}

function drawBall() {
    ctx.beginPath(); ctx.arc(x, y, ballRadius, 0, Math.PI * 2);
    ctx.fillStyle = "#fff"; ctx.fill(); ctx.closePath();
}

function drawPaddle() {
    ctx.beginPath();
    ctx.roundRect(paddleX, canvas.height - paddleHeight - 5, paddleWidth, paddleHeight, 5);
    ctx.fillStyle = varColor('--neon-blue'); ctx.fill(); ctx.closePath();
}

function varColor(name) { return getComputedStyle(document.documentElement).getPropertyValue(name); }

function drawBricks() {
    const bw = (canvas.width - (brickOffsetLeft * 2) - (colCount - 1) * brickPadding) / colCount;
    const bh = 18;
    bricks.forEach(col => col.forEach(b => {
        if (b.status === 1) {
            ctx.beginPath(); ctx.roundRect(b.x, b.y, bw, bh, 3);
            ctx.fillStyle = b.color; ctx.fill(); ctx.closePath();
        }
    }));
}

function updateUI() {
    document.getElementById("lv-txt").innerText = level;
    document.getElementById("score-txt").innerText = score;
}

let animFrame;
function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawBricks(); drawBall(); drawPaddle(); collisionDetection();

    if (x + dx > canvas.width - ballRadius || x + dx < ballRadius) dx = -dx;
    if (y + dy < ballRadius) dy = -dy;
    else if (y + dy > canvas.height - ballRadius - 5) {
        if (x > paddleX && x < paddleX + paddleWidth) {
            let hitPos = (x - (paddleX + paddleWidth/2)) / (paddleWidth/2);
            dx = hitPos * 4; dy = -dy;
        } else {
            alert("ğŸ’€ éŠæˆ²çµæŸï¼å¾—åˆ†: " + score);
            resetGame(true); return;
        }
    }
    x += dx; y += dy;
    animFrame = requestAnimationFrame(draw);
}

function resetGame(fullReset) {
    if (fullReset) { level = 1; score = 0; }
    cancelAnimationFrame(animFrame);
    initLevel();
    draw();
}

initLevel();
draw();
</script>
</body>
</html>
