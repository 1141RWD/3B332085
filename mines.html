<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-select=none">
    <title>ğŸ’£ éœ“è™¹æƒé›· - Speedrun</title>
    <style>
        :root { --neon-blue: #00f2fe; --neon-red: #ff4136; --bg: #0f172a; }
        body {
            margin: 0; background: var(--bg); color: white;
            font-family: 'Segoe UI', sans-serif; text-align: center;
            overflow: hidden; touch-action: none;
        }
        .header { padding: 15px; background: rgba(0,0,0,0.3); }
        .stats-bar { display: flex; justify-content: space-around; margin-bottom: 10px; font-weight: bold; }
        .stat-item span { color: var(--neon-blue); }

        #grid {
            display: grid; margin: 10px auto;
            gap: 4px; padding: 10px;
            background: rgba(255,255,255,0.05);
            border-radius: 10px; width: fit-content;
            border: 2px solid #1e293b;
        }
        .cell {
            width: 38px; height: 38px; background: #1e293b;
            border-radius: 4px; display: flex; align-items: center;
            justify-content: center; font-size: 1.2rem; cursor: pointer;
            transition: 0.15s; user-select: none;
        }
        .cell.revealed { background: #020617; border: 1px solid #334155; }
        .cell.mine { background: var(--neon-red); box-shadow: 0 0 10px var(--neon-red); }
        .cell.flagged { color: var(--neon-red); animation: pulse 1s infinite; }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
        
        .n1 { color: #38bdf8; } .n2 { color: #4ade80; } .n3 { color: #fb7185; }
        
        .controls { margin-top: 10px; font-size: 0.8rem; color: #8892b0; }
        .btns { margin-top: 15px; display: flex; justify-content: center; gap: 10px; }
        button {
            padding: 10px 20px; border-radius: 20px;
            border: 1px solid var(--neon-blue); background: transparent;
            color: var(--neon-blue); cursor: pointer; font-weight: bold;
        }
        #best-time-msg { color: #fbbf24; font-size: 0.9rem; margin-top: 10px; }
    </style>
</head>
<body>

<div class="header">
    <div class="stats-bar">
        <div class="stat-item">ğŸš© <span id="mine-count">10</span></div>
        <div class="stat-item">â±ï¸ <span id="timer">0</span>s</div>
    </div>
    <div id="best-time-msg">å€‹äººæœ€ä½³: <span id="best-time">--</span>s</div>
</div>

<div id="grid"></div>

<div class="controls">é»æ“Šé–‹æŒ– / å¿«é€Ÿé»å…©ä¸‹æ’æ——</div>

<div class="btns">
    <button onclick="initGame()">é‡æ–°é–‹å§‹</button>
    <button onclick="location.href='index.html'">è¿”å›å¤§å»³</button>
</div>

<script>
    const rows = 10, cols = 8, mineNum = 10;
    let board = [], revealedCount = 0, flags = 0, gameOver = false;
    let timerInterval, seconds = 0, gameStarted = false;

    // è¼‰å…¥æœ€ä½³ç´€éŒ„
    function loadBestTime() {
        const best = localStorage.getItem('minesweeper_best');
        document.getElementById('best-time').innerText = best ? best : "--";
    }

    function initGame() {
        const grid = document.getElementById('grid');
        grid.innerHTML = '';
        grid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
        board = []; revealedCount = 0; flags = 0; gameOver = false;
        gameStarted = false; seconds = 0;
        clearInterval(timerInterval);
        document.getElementById('timer').innerText = 0;
        document.getElementById('mine-count').innerText = mineNum;
        loadBestTime();

        for (let r = 0; r < rows; r++) {
            board[r] = [];
            for (let c = 0; c < cols; c++) {
                const el = document.createElement('div');
                el.classList.add('cell');
                
                // è™•ç†é›™æ“Š (Double Click / Double Tap)
                let lastClickTime = 0;
                el.addEventListener('click', (e) => {
                    const currentTime = new Date().getTime();
                    if (currentTime - lastClickTime < 300) {
                        // é›™æ“Šï¼šæ’æ——
                        toggleFlag(r, c);
                    } else {
                        // å–®æ“Šï¼šé–‹æŒ– (å»¶é²ä¸€ä¸‹åˆ¤æ–·æ˜¯å¦ç‚ºé›™æ“Š)
                        setTimeout(() => {
                            if (new Date().getTime() - lastClickTime >= 300) {
                                reveal(r, c);
                            }
                        }, 300);
                    }
                    lastClickTime = currentTime;
                });

                grid.appendChild(el);
                board[r][c] = { mine: false, revealed: false, flagged: false, count: 0, el };
            }
        }

        // åŸ‹é›·èˆ‡è¨ˆç®—æ•¸å­—é‚è¼¯åŒå‰...
        let placed = 0;
        while (placed < mineNum) {
            let r = Math.floor(Math.random() * rows), c = Math.floor(Math.random() * cols);
            if (!board[r][c].mine) { board[r][c].mine = true; placed++; }
        }
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                if (board[r][c].mine) continue;
                let count = 0;
                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        if (board[r+i]?.[c+j]?.mine) count++;
                    }
                }
                board[r][c].count = count;
            }
        }
    }

    function startTimer() {
        if (!gameStarted) {
            gameStarted = true;
            timerInterval = setInterval(() => {
                seconds++;
                document.getElementById('timer').innerText = seconds;
            }, 1000);
        }
    }

    function reveal(r, c) {
        if (gameOver || board[r][c].revealed || board[r][c].flagged) return;
        startTimer();
        
        const cell = board[r][c];
        cell.revealed = true;
        cell.el.classList.add('revealed');

        if (cell.mine) {
            endGame(false);
            return;
        }

        if (cell.count > 0) {
            cell.el.innerText = cell.count;
            cell.el.classList.add('n' + cell.count);
        } else {
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    if (board[r+i]?.[c+j]) reveal(r+i, c+j);
                }
            }
        }

        revealedCount++;
        if (revealedCount === rows * cols - mineNum) endGame(true);
    }

    function toggleFlag(r, c) {
        if (gameOver || board[r][c].revealed) return;
        startTimer();
        const cell = board[r][c];
        cell.flagged = !cell.flagged;
        cell.el.innerText = cell.flagged ? 'ğŸš©' : '';
        cell.el.classList.toggle('flagged');
        flags += cell.flagged ? 1 : -1;
        document.getElementById('mine-count').innerText = mineNum - flags;
    }

    function endGame(isWin) {
        gameOver = true;
        clearInterval(timerInterval);
        if (isWin) {
            const best = localStorage.getItem('minesweeper_best');
            if (!best || seconds < parseInt(best)) {
                localStorage.setItem('minesweeper_best', seconds);
                alert(`ğŸŠ æ–°ç´€éŒ„ï¼ä½ èŠ±äº† ${seconds} ç§’ã€‚`);
            } else {
                alert(`ğŸ‰ æˆåŠŸé€šé—œï¼æ™‚é–“: ${seconds} ç§’ã€‚`);
            }
        } else {
            board.flat().forEach(c => {
                if(c.mine) { c.el.innerText = 'ğŸ’£'; c.el.classList.add('mine'); }
            });
            alert('ğŸ’¥ ç¢°åˆ°åœ°é›·ï¼ŒæŒ‘æˆ°å¤±æ•—ï¼');
        }
        loadBestTime();
    }

    initGame();
</script>
</body>
</html>
