<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8" />
<title>五子棋雙人遊戲</title>
  <div id="home-btn-container" onclick="window.location.href='index.html'">
    <svg viewBox="0 0 24 24" width="24" height="24">
        <path fill="currentColor" d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
    </svg>
    <span>大廳</span>
</div>
<style>
  body {
    background: #f0d9b5;
    font-family: "Microsoft JhengHei", Arial, sans-serif;
    text-align: center;
    margin: 20px;
  }
  h1 {
    margin-bottom: 10px;
  }
  #status {
    margin-bottom: 10px;
    font-size: 18px;
    font-weight: bold;
  }
  canvas {
    background: #deb887;
    border: 2px solid #8b5a2b;
    cursor: pointer;
  }
  button {
    margin-top: 10px;
    padding: 6px 16px;
    font-size: 16px;
    cursor: pointer;
  }
  #home-btn-container {
        position: fixed;
        top: 15px;
        left: 15px;
        z-index: 9999; /* 確保在所有遊戲元素之上 */
        display: flex;
        align-items: center;
        gap: 5px;
        padding: 8px 15px;
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(8px);
        border: 1px solid rgba(0, 12, 24, 0.5);
        border-radius: 50px;
        color: #00f2fe;
        cursor: pointer;
        font-family: 'Segoe UI', sans-serif;
        font-weight: bold;
        font-size: 14px;
        box-shadow: 0 0 15px rgba(0, 242, 254, 0.2);
        transition: 0.3s;
        user-select: none;
    }

    #home-btn-container:hover {
        background: rgba(50, 50, 54, 0.2);
        box-shadow: 0 0 20px rgba(0, 242, 254, 0.5);
        transform: scale(1.05);
    }

    #home-btn-container:active {
        transform: scale(0.95);
    }

    /* 手機版微調：如果覺得太大可以縮小一點 */
    @media (max-width: 480px) {
        #home-btn-container {
            top: 10px;
            left: 10px;
            padding: 6px 12px;
            font-size: 12px;
        }
    }
</style>
</head>
<body>

<h1>五子棋雙人遊戲</h1>
<div id="status">輪到 黑棋 下子</div>
<canvas id="board" width="600" height="600"></canvas>
<br />
<button onclick="resetGame()">重新開始</button>

<script>
const canvas = document.getElementById("board");
const ctx = canvas.getContext("2d");

const size = 15;          // 棋盤格數
const cellSize = 40;      // 每格大小 (px)
const stoneRadius = 16;   // 棋子半徑

// 棋盤資料，0=空，1=黑，2=白
let board = [];
let currentPlayer = 1; // 1=黑，2=白
let gameOver = false;

function initBoard() {
  board = [];
  for(let i=0; i<size; i++) {
    board[i] = [];
    for(let j=0; j<size; j++) {
      board[i][j] = 0;
    }
  }
  currentPlayer = 1;
  gameOver = false;
  updateStatus(`輪到 黑棋 下子`);
  drawBoard();
}

function drawBoard() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  // 畫線
  ctx.strokeStyle = "#8b5a2b";
  for(let i=0; i<size; i++) {
    // 橫線
    ctx.beginPath();
    ctx.moveTo(cellSize/2, cellSize/2 + i*cellSize);
    ctx.lineTo(cellSize/2 + (size-1)*cellSize, cellSize/2 + i*cellSize);
    ctx.stroke();
    // 豎線
    ctx.beginPath();
    ctx.moveTo(cellSize/2 + i*cellSize, cellSize/2);
    ctx.lineTo(cellSize/2 + i*cellSize, cellSize/2 + (size-1)*cellSize);
    ctx.stroke();
  }
  // 畫星位(天元、四個角點)
  const starPoints = [
    [3,3],[3,11],[7,7],[11,3],[11,11]
  ];
  starPoints.forEach(([x,y])=>{
    ctx.beginPath();
    ctx.fillStyle = "#8b5a2b";
    ctx.arc(cellSize/2 + x*cellSize, cellSize/2 + y*cellSize, 5, 0, 2*Math.PI);
    ctx.fill();
  });
  // 畫棋子
  for(let i=0; i<size; i++) {
    for(let j=0; j<size; j++) {
      if(board[i][j] !== 0) {
        drawStone(i, j, board[i][j]);
      }
    }
  }
}

function drawStone(i, j, player) {
  const x = cellSize/2 + i*cellSize;
  const y = cellSize/2 + j*cellSize;
  const gradient = ctx.createRadialGradient(x-6, y-6, stoneRadius/2, x, y, stoneRadius);
  if(player === 1) { // 黑子
    gradient.addColorStop(0, "#666");
    gradient.addColorStop(1, "#000");
  } else { // 白子
    gradient.addColorStop(0, "#fff");
    gradient.addColorStop(1, "#ddd");
  }
  ctx.beginPath();
  ctx.fillStyle = gradient;
  ctx.arc(x, y, stoneRadius, 0, 2*Math.PI);
  ctx.fill();
  ctx.strokeStyle = "#555";
  ctx.stroke();
}

function updateStatus(text) {
  document.getElementById("status").textContent = text;
}

function checkWin(x, y) {
  const player = board[x][y];
  if(player === 0) return false;

  // 方向向量(8方向，但只需4方向往雙邊檢查)
  const directions = [
    [1,0], [0,1], [1,1], [1,-1]
  ];

  for(let [dx, dy] of directions) {
    let count = 1;

    // 向一邊延伸
    for(let step=1; step<5; step++) {
      let nx = x + dx*step;
      let ny = y + dy*step;
      if(nx<0||ny<0||nx>=size||ny>=size) break;
      if(board[nx][ny] === player) count++;
      else break;
    }
    // 向另一邊延伸
    for(let step=1; step<5; step++) {
      let nx = x - dx*step;
      let ny = y - dy*step;
      if(nx<0||ny<0||nx>=size||ny>=size) break;
      if(board[nx][ny] === player) count++;
      else break;
    }

    if(count >= 5) return true;
  }
  return false;
}

// 轉換點擊座標到棋格座標
function getCellFromCoords(px, py) {
  const rect = canvas.getBoundingClientRect();
  const x = px - rect.left;
  const y = py - rect.top;

  // 轉換成最近的格子座標
  const i = Math.round((x - cellSize/2) / cellSize);
  const j = Math.round((y - cellSize/2) / cellSize);

  if(i < 0 || i >= size || j < 0 || j >= size) return null;
  return { i, j };
}

// 點擊下子
canvas.addEventListener("click", e => {
  if(gameOver) return;
  const cell = getCellFromCoords(e.clientX, e.clientY);
  if(!cell) return;
  if(board[cell.i][cell.j] !== 0) return;

  board[cell.i][cell.j] = currentPlayer;
  drawBoard();

  if(checkWin(cell.i, cell.j)) {
    updateStatus((currentPlayer === 1 ? "黑棋" : "白棋") + " 勝利！");
    gameOver = true;
    return;
  }

  currentPlayer = 3 - currentPlayer; // 1 <-> 2
  updateStatus("輪到 " + (currentPlayer === 1 ? "黑棋" : "白棋") + " 下子");
});

function resetGame() {
  initBoard();
}

initBoard();
</script>

</body>
</html>



