<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-select=none">
    <title>ğŸš§ æ¥µé™é¿éšœï¼šè¬èŠ±ç­’ - Arcade Hub</title>
    <style>
        :root { --neon-blue: #00f2fe; --bg: #020205; }
        body {
            margin: 0; background: var(--bg); color: white;
            font-family: 'Segoe UI', sans-serif; overflow: hidden;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            height: 100vh; touch-action: none;
        }

        /* çµ±ä¸€å›é¦–é æŒ‰éˆ• */
        #home-btn-container {
            position: fixed; top: 15px; left: 15px; z-index: 9999;
            display: flex; align-items: center; gap: 5px; padding: 8px 15px;
            background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(8px);
            border: 1px solid rgba(0, 242, 254, 0.5); border-radius: 50px;
            color: var(--neon-blue); cursor: pointer; font-weight: bold; font-size: 14px;
        }

        #ui { position: absolute; top: 80px; text-align: center; pointer-events: none; z-index: 10; }
        .timer { font-size: 3.5rem; font-weight: bold; color: var(--neon-blue); text-shadow: 0 0 20px var(--neon-blue); }
        
        canvas { display: block; }
        
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); display: none;
            flex-direction: column; align-items: center; justify-content: center;
            z-index: 100;
        }
        .result-title { font-size: 2.5rem; margin-bottom: 20px; font-weight: bold; }
        button {
            padding: 15px 40px; border-radius: 30px; border: 2px solid var(--neon-blue);
            background: rgba(0, 242, 254, 0.1); color: var(--neon-blue); font-weight: bold; cursor: pointer; font-size: 1.1rem;
        }
    </style>
</head>
<body>

    <div id="home-btn-container" onclick="window.location.href='index.html'">
        <svg viewBox="0 0 24 24" width="24" height="24"><path fill="currentColor" d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg>
        <span>å¤§å»³</span>
    </div>

    <div id="ui">
        <div class="timer" id="timer">15.00</div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="overlay">
        <div class="result-title" id="result-text">MISSION FAILED</div>
        <button onclick="resetGame()">é‡æ–°åˆå§‹åŒ–ç³»çµ±</button>
    </div>



<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const timerEl = document.getElementById('timer');
    const overlay = document.getElementById('overlay');
    const resultText = document.getElementById('result-text');

    // é¡è‰²æ¸…å–®
    const COLORS = ['#ff00cc', '#00f2fe', '#4ade80', '#fbbf24', '#ff4136', '#8b5cf6', '#f472b6'];
    
    let width, height, centerX, centerY;
    let playerAngle = 0;
    let obstacles = [];
    let gameActive = false;
    let timeLeft = 20;
    let lastTime = 0;
    let worldRotation = 0;
    let lastGapAngle = Math.random() * Math.PI * 2;
    let lastSpawnTime = 0;
    const SPAWN_INTERVAL = 1400; // å¼·åˆ¶ 1.4 ç§’é–“è·

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        centerX = width / 2;
        centerY = height / 2;
    }
    window.addEventListener('resize', resize);
    resize();

    class Obstacle {
        constructor() {
            this.distance = Math.max(width, height) * 0.7;
            this.gapSize = 1.0; // ç¼ºå£å¯¬åº¦ (å¼§åº¦)
            this.thickness = 18;
            this.speed = 4;
            this.color = COLORS[Math.floor(Math.random() * COLORS.length)];
            
            // ç¢ºä¿ç¼ºå£è·¯å¾‘åˆç†ï¼šé™åˆ¶åœ¨ä¸Šä¸€å€‹ç¼ºå£çš„æ­£è²  75 åº¦å…§
            let offset = (Math.random() * 2 - 1) * 1.3;
            this.gapAngle = lastGapAngle + offset;
            lastGapAngle = this.gapAngle;
        }

        update() {
            this.distance -= this.speed;
            // ç¢°æ’åˆ¤å®šå€ (ç©å®¶è»Œé“åœ¨ 60px è™•)
            return this.distance < 70 && this.distance > 50;
        }

        draw() {
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(worldRotation);
            ctx.beginPath();
            ctx.lineWidth = this.thickness;
            ctx.strokeStyle = this.color;
            ctx.shadowBlur = 15;
            ctx.shadowColor = this.color;
            // ç¹ªè£½åœ“ç’°ï¼Œä¿ç•™ç¼ºå£
            ctx.arc(0, 0, this.distance, this.gapAngle + this.gapSize, this.gapAngle + Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }
    }

    function resetGame() {
        obstacles = [];
        timeLeft = 20;
        playerAngle = 0;
        worldRotation = 0;
        lastSpawnTime = 0;
        gameActive = true;
        overlay.style.display = 'none';
        lastTime = performance.now();
        requestAnimationFrame(gameLoop);
    }

    function gameLoop(time) {
        if (!gameActive) return;
        const deltaTime = (time - lastTime) / 1000;
        lastTime = time;
        timeLeft -= deltaTime;

        if (timeLeft <= 0) return winGame();
        timerEl.innerText = Math.max(0, timeLeft).toFixed(2);

        // æ§åˆ¶ç”Ÿæˆç¯€å¥
        if (time - lastSpawnTime > SPAWN_INTERVAL) {
            obstacles.push(new Obstacle());
            lastSpawnTime = time;
        }

        // èƒŒæ™¯èˆ‡è£é£¾
        ctx.fillStyle = '#020205';
        ctx.fillRect(0, 0, width, height);

        // ç•«å‡ºæ·¡æ·¡çš„ä¸­å¿ƒé»èˆ‡è»Œé“
        ctx.beginPath();
        ctx.arc(centerX, centerY, 60, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(255,255,255,0.05)';
        ctx.stroke();

        worldRotation += 0.006; // ç·©æ…¢æ—‹è½‰èƒŒæ™¯

        // ç¹ªè£½ç©å®¶
        drawPlayer(time);

        // è™•ç†éšœç¤™ç‰©
        for (let i = obstacles.length - 1; i >= 0; i--) {
            const obs = obstacles[i];
            obs.draw();
            
            if (obs.update()) {
                // ç¢°æ’æª¢æŸ¥é‚è¼¯
                let p = (playerAngle % (Math.PI * 2) + Math.PI * 2) % (Math.PI * 2);
                let gS = (obs.gapAngle % (Math.PI * 2) + Math.PI * 2) % (Math.PI * 2);
                let gE = gS + obs.gapSize;

                let safe = false;
                if (gE > Math.PI * 2) {
                    if (p >= gS || p <= gE - Math.PI * 2) safe = true;
                } else {
                    if (p >= gS && p <= gE) safe = true;
                }

                if (!safe) return gameOver();
                obstacles.splice(i, 1);
            }
        }
        requestAnimationFrame(gameLoop);
    }

    function drawPlayer(time) {
        ctx.save();
        ctx.translate(centerX, centerY);
        ctx.rotate(playerAngle + worldRotation);
        
        // ç•«ç©å®¶ä¸»é«”
        let pulse = Math.sin(time / 150) * 4;
        ctx.shadowBlur = 20 + pulse;
        ctx.shadowColor = 'var(--neon-blue)';
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(60, 0, 10, 0, Math.PI * 2);
        ctx.fill();
        
        // è£é£¾å¤–ç’°
        ctx.strokeStyle = 'var(--neon-blue)';
        ctx.lineWidth = 3;
        ctx.stroke();
        ctx.restore();
    }

    function gameOver() {
        gameActive = false;
        resultText.innerText = "ğŸ’¥ å¤±æ•—";
        resultText.style.color = "#ff4136";
        overlay.style.display = 'flex';
    }

    function winGame() {
        gameActive = false;
        resultText.innerText = "ğŸ† æˆåŠŸ";
        resultText.style.color = "var(--neon-blue)";
        overlay.style.display = 'flex';
    }

    // æ§åˆ¶é‚è¼¯
    let lastX = 0;
    function handleMove(e) {
        if (!gameActive) return;
        const x = e.touches ? e.touches[0].clientX : e.clientX;
        const deltaX = x - lastX;
        playerAngle += deltaX * 0.018; // éˆæ•åº¦èª¿æ•´
        lastX = x;
    }

    window.addEventListener('mousedown', e => { lastX = e.clientX; window.addEventListener('mousemove', handleMove); });
    window.addEventListener('mouseup', () => window.removeEventListener('mousemove', handleMove));
    window.addEventListener('touchstart', e => { lastX = e.touches[0].clientX; }, {passive: false});
    window.addEventListener('touchmove', e => { handleMove(e); }, {passive: false});

    resetGame();
</script>
</body>
</html>
